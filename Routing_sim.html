<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Flow Simulator</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --input: #334155;
            --text: #f1f5f9;
            --accent: #38bdf8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
        }
        html, body { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: var(--bg); color: var(--text); 
            font-family: 'Segoe UI', sans-serif; overflow: hidden; 
        }
        #app { display: flex; width: 100%; height: 100%; }
        .sidebar { 
            width: 300px; min-width: 300px; background: var(--panel); 
            padding: 20px; display: flex; flex-direction: column; gap: 15px; 
            border-right: 1px solid #333; overflow-y: auto; z-index: 10;
        }
        h2 { margin: 0 0 10px 0; color: var(--accent); font-size: 1.2rem; }
        h3 { margin: 15px 0 5px 0; font-size: 0.9rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 1px; }
        .control-group { background: var(--input); padding: 10px; border-radius: 6px; }
        label { display: block; font-size: 0.85rem; margin-bottom: 5px; color: #cbd5e1; }
        input[type="number"] { width: 90%; background: var(--bg); border: 1px solid #475569; color: white; padding: 6px; border-radius: 4px; }
        button { background: var(--accent); color: var(--bg); border: none; padding: 10px; border-radius: 6px; font-weight: bold; cursor: pointer; transition: 0.2s; width: 100%; }
        button:hover { filter: brightness(1.1); }
        button.secondary { background: var(--input); color: var(--text); margin-top: 5px; }
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .stat-box { background: var(--bg); padding: 10px; border-radius: 4px; text-align: center; border: 1px solid #333; }
        .stat-val { font-size: 1.1rem; font-weight: bold; display: block; }
        .nash-val { color: var(--warning); }
        .opt-val { color: var(--success); }
        .instructions { font-size: 0.8rem; color: #94a3b8; line-height: 1.4; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; }
        .main { flex-grow: 1; position: relative; background: #000; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        .status-bar { position: absolute; bottom: 20px; left: 20px; background: rgba(15, 23, 42, 0.9); padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; pointer-events: none; border: 1px solid var(--accent); color: var(--accent); }
        #edgeEditor { position: absolute; display: none; background: var(--panel); border: 1px solid var(--accent); padding: 15px; border-radius: 8px; width: 200px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); z-index: 100; }
    </style>
</head>
<body>


<div id="app">
    <div class="sidebar">
        <h2>Traffic Simulator</h2>
        <div class="control-group">
            <label>Total Cars (N)</label>
            <input type="number" id="numCars" value="4000" min="1" max="10000">
        </div>
        <button onclick="runSimulation()">▶ Run Simulation</button>
        <div class="stats">
            <div class="stat-box"><span style="font-size:0.8rem">Nash Avg Time</span><span class="stat-val nash-val" id="nashTime">-</span></div>
            <div class="stat-box"><span style="font-size:0.8rem">Optimal Avg Time</span><span class="stat-val opt-val" id="optTime">-</span></div>
        </div>
        <div class="stat-box" style="grid-column: span 2;">
            <span style="font-size:0.8rem">Price of Anarchy</span><span class="stat-val" id="poa" style="color:white">-</span>
        </div>
        <h3>Graph Controls</h3>
        <button class="secondary" onclick="resetGraph()">⚠ Clear Graph</button>
        <button class="secondary" onclick="loadBraess()">Load Braess Paradox</button>
        <h3>Instructions</h3>
        <div class="instructions">
            • <b>Double Click</b>: Add Node<br>• <b>Click Node A then B</b>: Add Road<br>• <b>Drag Node</b>: Move<br>• <b>Right Click</b>: Delete Node/Road<br>• <b>Click Road Text</b>: Edit Weights
        </div>
        <div id="logs" style="font-family: monospace; font-size: 0.75rem; color: #64748b; margin-top: auto; max-height: 150px; overflow-y: auto;"></div>
    </div>
    <div class="main" id="canvasContainer">
        <canvas id="canvas"></canvas>
        <div class="status-bar" id="statusBar">Initializing...</div>
    </div>
</div>


<div id="edgeEditor">
    <h4 style="margin: 0 0 10px 0; color: var(--accent);">Edit Road</h4>
    <label>Base Time (a)</label><input type="number" id="editA" step="1"><br><br>
    <label>Congestion Factor (b)</label><input type="number" id="editB" step="0.001"><br><br>
    <button onclick="saveEdgeEdit()">Save</button>
    <button class="secondary" onclick="closeEditor()" style="margin-top:5px">Cancel</button>
</div>


<script>
let nodes = [], edges = [], nextNodeId = 1, nextEdgeId = 1;
let selectedNode = null, draggingNode = null, editingEdge = null;
const RADIUS = 18, ARROW_SIZE = 10;
let CANVAS, CTX, CONTAINER;


window.addEventListener('load', () => {
    CANVAS = document.getElementById('canvas');
    CTX = CANVAS.getContext('2d');
    CONTAINER = document.getElementById('canvasContainer');
    resize();
    // loadBraess(); // Removed default load
    window.addEventListener('resize', resize);
    setupInteractions();
});


function resize() {
    if(CONTAINER && CANVAS) {
        CANVAS.width = CONTAINER.clientWidth;
        CANVAS.height = CONTAINER.clientHeight;
        draw();
    }
}
function log(msg) {
    console.log(msg);
    const l = document.getElementById('logs');
    if(l) { l.innerHTML += `> ${msg}<br>`; l.scrollTop = l.scrollHeight; }
    const sb = document.getElementById('statusBar');
    if(sb) sb.innerText = msg;
}


// --- Interactions ---
function setupInteractions() {
    CANVAS.addEventListener('dblclick', (e) => {
        const pos = getMousePos(e);
        if (findNodeAt(pos)) return;
        nodes.push({ id: nextNodeId++, x: pos.x, y: pos.y });
        draw();
    });
    CANVAS.addEventListener('mousedown', (e) => {
        if(e.button !== 0) return;
        const pos = getMousePos(e);
        const node = findNodeAt(pos);
        const edge = findEdgeAt(pos);
        if (node) {
            if (!selectedNode) { selectedNode = node; draggingNode = node; }
            else {
                if (selectedNode.id !== node.id) {
                    const exists = edges.find(ed => ed.source === selectedNode.id && ed.target === node.id);
                    if (!exists) {
                        edges.push({ id: nextEdgeId++, source: selectedNode.id, target: node.id, a: 0, b: 0.01, nashFlow: 0, optFlow: 0 });
                        log(`Road created: ${selectedNode.id} → ${node.id}`);
                    }
                }
                selectedNode = null; draggingNode = node;
            }
        } else if (edge) { openEditor(edge, e.clientX, e.clientY); selectedNode = null; }
        else { selectedNode = null; }
        draw();
    });
    CANVAS.addEventListener('mousemove', (e) => {
        if (draggingNode) {
            const pos = getMousePos(e); draggingNode.x = pos.x; draggingNode.y = pos.y; draw();
        }
    });
    window.addEventListener('mouseup', () => { draggingNode = null; });
    CANVAS.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const pos = getMousePos(e);
        const node = findNodeAt(pos);
        const edge = findEdgeAt(pos);
        if (node) {
            nodes = nodes.filter(n => n.id !== node.id);
            edges = edges.filter(ed => ed.source !== node.id && ed.target !== node.id);
            if(selectedNode === node) selectedNode = null;
        } else if (edge) edges = edges.filter(ed => ed.id !== edge.id);
        draw();
    });
}
function getMousePos(evt) { const rect = CANVAS.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
function findNodeAt(pos) { return nodes.find(n => Math.hypot(n.x - pos.x, n.y - pos.y) < RADIUS + 5); }
function findEdgeAt(pos) {
    for (let e of edges) {
        const s = nodes.find(n => n.id === e.source); const t = nodes.find(n => n.id === e.target);
        if(!s || !t) continue;
        const l2 = (s.x - t.x)**2 + (s.y - t.y)**2; if (l2 === 0) continue;
        let t_proj = ((pos.x - s.x)*(t.x - s.x) + (pos.y - s.y)*(t.y - s.y)) / l2;
        t_proj = Math.max(0, Math.min(1, t_proj));
        const px = s.x + t_proj*(t.x - s.x); const py = s.y + t_proj*(t.y - s.y);
        if (Math.hypot(pos.x - px, pos.y - py) < 10) return e;
    }
    return null;
}
function openEditor(edge, mx, my) {
    editingEdge = edge;
    const panel = document.getElementById('edgeEditor');
    panel.style.display = 'block'; panel.style.left = Math.min(window.innerWidth - 220, mx)+'px'; panel.style.top = Math.min(window.innerHeight - 250, my)+'px';
    document.getElementById('editA').value = edge.a; document.getElementById('editB').value = edge.b;
}
function saveEdgeEdit() {
    if (editingEdge) {
        editingEdge.a = parseFloat(document.getElementById('editA').value) || 0;
        editingEdge.b = parseFloat(document.getElementById('editB').value) || 0;
        draw(); closeEditor();
    }
}
function closeEditor() { document.getElementById('edgeEditor').style.display = 'none'; editingEdge = null; }


// --- Drawing ---
function draw() {
    if(!CTX) return;
    CTX.fillStyle = '#0f172a'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
    // Grid
    CTX.strokeStyle = 'rgba(255,255,255,0.05)'; CTX.lineWidth = 1;
    for(let i=0; i<CANVAS.width; i+=50) { CTX.beginPath(); CTX.moveTo(i,0); CTX.lineTo(i, CANVAS.height); CTX.stroke(); }
    for(let i=0; i<CANVAS.height; i+=50) { CTX.beginPath(); CTX.moveTo(0,i); CTX.lineTo(CANVAS.width, i); CTX.stroke(); }
    // Edges
    edges.forEach(e => {
        const s = nodes.find(n => n.id === e.source); const t = nodes.find(n => n.id === e.target);
        if(!s || !t) return;
        const dx = t.x - s.x, dy = t.y - s.y, angle = Math.atan2(dy, dx);
        const sx = s.x + Math.cos(angle)*RADIUS, sy = s.y + Math.sin(angle)*RADIUS;
        const ex = t.x - Math.cos(angle)*RADIUS, ey = t.y - Math.sin(angle)*RADIUS;
        CTX.beginPath(); CTX.moveTo(sx, sy); CTX.lineTo(ex, ey); CTX.strokeStyle = '#64748b'; CTX.lineWidth = 3; CTX.stroke();
        CTX.beginPath(); CTX.moveTo(ex, ey);
        CTX.lineTo(ex - ARROW_SIZE*Math.cos(angle-Math.PI/6), ey - ARROW_SIZE*Math.sin(angle-Math.PI/6));
        CTX.lineTo(ex - ARROW_SIZE*Math.cos(angle+Math.PI/6), ey - ARROW_SIZE*Math.sin(angle+Math.PI/6));
        CTX.fillStyle = '#64748b'; CTX.fill();
        const mx = (s.x + t.x)/2, my = (s.y + t.y)/2;
        CTX.fillStyle = 'rgba(15, 23, 42, 0.85)'; CTX.fillRect(mx - 60, my - 30, 120, 60);
        CTX.fillStyle = '#e2e8f0'; CTX.font = '12px monospace'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
        CTX.fillStyle = '#94a3b8'; CTX.fillText(`w=${e.a}+${e.b}l`, mx, my - 12);
        CTX.fillStyle = '#f59e0b'; CTX.fillText(`N:${e.nashFlow}`, mx, my + 4);
        CTX.fillStyle = '#22c55e'; CTX.fillText(`O:${Math.round(e.optFlow)}`, mx, my + 18);
    });
    // Nodes
    nodes.forEach((n, index) => {
        CTX.beginPath(); CTX.arc(n.x, n.y, RADIUS, 0, Math.PI*2);
        if (index === 0) CTX.fillStyle = '#22c55e';
        else if (index === 1 && nodes.length > 1) CTX.fillStyle = '#ef4444';
        else CTX.fillStyle = '#3b82f6';
        if (selectedNode === n) CTX.fillStyle = '#fbbf24';
        CTX.fill(); CTX.strokeStyle = '#fff'; CTX.lineWidth = 2; CTX.stroke();
        CTX.fillStyle = '#fff'; CTX.font = 'bold 12px Arial'; CTX.textAlign = 'center'; CTX.textBaseline = 'middle';
        CTX.fillText(index===0?'S':(index===1?'T':n.id), n.x, n.y);
    });
}


// --- Logic ---
function shortestPath(startId, endId, flowMap, isMarginal) {
    const dist = {}, prev = {};
    nodes.forEach(n => dist[n.id] = Infinity); dist[startId] = 0;
    const unvisited = new Set(nodes.map(n => n.id));
    while(unvisited.size > 0) {
        let u = null, minDist = Infinity;
        for (let id of unvisited) if (dist[id] < minDist) { minDist = dist[id]; u = id; }
        if (u === null || u === endId) break;
        unvisited.delete(u);
        const myEdges = edges.filter(e => e.source === u);
        for (let e of myEdges) {
            if (!unvisited.has(e.target)) continue;
            const f = flowMap[e.id] || 0;
            const cost = isMarginal ? (e.a + 2*e.b*f) : (e.a + e.b*f);
            if (dist[u] + cost < dist[e.target]) { dist[e.target] = dist[u] + cost; prev[e.target] = e; }
        }
    }
    const path = []; let curr = endId;
    while(curr !== startId) { const e = prev[curr]; if(!e) return null; path.push(e); curr = e.source; }
    return path.reverse();
}


function runNash(N, startId, endId) {
    let flows = {}; edges.forEach(e => flows[e.id] = 0);
    for (let i = 0; i < N; i++) {
        const path = shortestPath(startId, endId, flows, false);
        if (!path) return 0;
        path.forEach(e => flows[e.id]++);
    }
    let total = 0;
    edges.forEach(e => { e.nashFlow = flows[e.id]; total += e.nashFlow*(e.a + e.b*e.nashFlow); });
    return total / N;
}


// Fixed Frank-Wolfe with Line Search
function runOptimal(N, startId, endId) {
    let x = {}; edges.forEach(e => x[e.id] = 0);
    // Init: Assign all to shortest path (free flow)
    const p0 = shortestPath(startId, endId, x, false);
    if (!p0) return 0;
    p0.forEach(e => x[e.id] = N);


    const MAX_ITER = 50;
    for (let k = 0; k < MAX_ITER; k++) {
        // Subproblem: Shortest path with MARGINAL costs
        const pY = shortestPath(startId, endId, x, true);
        let y = {}; edges.forEach(e => y[e.id] = 0);
        pY.forEach(e => y[e.id] = N);
        
        // Line Search for optimal step size alpha (Golden Section)
        // minimize C(x + alpha*(y-x))
        let a = 0, b = 1;
        const PHI = (Math.sqrt(5) - 1) / 2;
        let c = b - PHI*(b-a), d = a + PHI*(b-a);
        while (Math.abs(b - a) > 1e-4) {
            if (calcTotalCost(x, y, c) < calcTotalCost(x, y, d)) b = d; else a = c;
            c = b - PHI*(b-a); d = a + PHI*(b-a);
        }
        const alpha = (a+b)/2;
        
        // Update x
        edges.forEach(e => x[e.id] = x[e.id] + alpha*(y[e.id] - x[e.id]));
    }
    
    let total = 0;
    edges.forEach(e => { e.optFlow = x[e.id]; total += e.optFlow*(e.a + e.b*e.optFlow); });
    return total / N;
}


function calcTotalCost(x, y, alpha) {
    let cost = 0;
    edges.forEach(e => {
        const f = x[e.id] + alpha * (y[e.id] - x[e.id]);
        cost += f * (e.a + e.b * f);
    });
    return cost;
}


function runSimulation() {
    if (nodes.length < 2) { log("Need 2+ nodes"); return; }
    const N = parseInt(document.getElementById('numCars').value);
    const startId = nodes[0].id, endId = nodes[1].id;
    
    const nashAvg = runNash(N, startId, endId);
    const optAvg = runOptimal(N, startId, endId);
    
    document.getElementById('nashTime').innerText = nashAvg.toFixed(2);
    document.getElementById('optTime').innerText = optAvg.toFixed(2);
    document.getElementById('poa').innerText = optAvg>0 ? (nashAvg/optAvg).toFixed(3) : "1.000";
    draw();
}


function resetGraph() {
    nodes = []; edges = []; nextNodeId = 1; nextEdgeId = 1;
    nodes.push({id: nextNodeId++, x: 100, y: 300}); nodes.push({id: nextNodeId++, x: 600, y: 300});
    draw();
}


function loadBraess() {
    nodes = []; edges = []; nextNodeId=1; nextEdgeId=1;
    // Layout like the diagram
    nodes.push({id: nextNodeId++, x: 100, y: 300}); // S
    nodes.push({id: nextNodeId++, x: 700, y: 300}); // T (End)
    nodes.push({id: nextNodeId++, x: 400, y: 100}); // A (Top)
    nodes.push({id: nextNodeId++, x: 400, y: 500}); // B (Bottom)
    
    document.getElementById('numCars').value = 4000;
    
    // Braess Weights per User Image
    // S -> A: T/100 => a=0, b=0.01
    edges.push({id: nextEdgeId++, source: 1, target: 3, a: 0, b: 0.01, nashFlow:0, optFlow:0});
    // A -> T: 45    => a=45, b=0
    edges.push({id: nextEdgeId++, source: 3, target: 2, a: 45, b: 0, nashFlow:0, optFlow:0});
    // S -> B: 45    => a=45, b=0
    edges.push({id: nextEdgeId++, source: 1, target: 4, a: 45, b: 0, nashFlow:0, optFlow:0});
    // B -> T: T/100 => a=0, b=0.01
    edges.push({id: nextEdgeId++, source: 4, target: 2, a: 0, b: 0.01, nashFlow:0, optFlow:0});
    // A -> B: 0     => a=0, b=0 (The Paradox Link)
    edges.push({id: nextEdgeId++, source: 3, target: 4, a: 0, b: 0, nashFlow:0, optFlow:0}); 


    draw(); log("Loaded Braess (4000 cars)");
}
</script>
</body>
</html>
